import { OpenXMLElement } from '../../../types/OpenXMLTypes';
import { ToJsonContext } from '../../base/IProcessor';
import { BasePlugin, ITextProcessorPlugin, PluginType, PluginMetadata } from '../IPlugin';
import { Plugin, InjectPlugin } from '../PluginDecorator';
import {
  TextProcessingResult,
  PlaceholderInfo
} from './types';
import { StyleProcessorPlugin } from './StyleProcessorPlugin';
import { ParagraphProcessorPlugin } from './ParagraphProcessorPlugin';
import { ParagraphInfo } from '@domain/types/ElementTypes';

/**
 * æ–‡æœ¬å¤„ç†æ’ä»¶
 * åè°ƒæ•´ä¸ªæ–‡æœ¬å¤„ç†æµç¨‹ï¼Œå®ç°æ ·å¼ç»§æ‰¿é“¾
 */
@Plugin({
  name: 'TextProcessorPlugin',
  type: PluginType.TEXT_PROCESSOR,
  targetProcessors: ['ShapeProcessor'],
  priority: 100,
  description: 'åè°ƒæ•´ä¸ªæ–‡æœ¬å¤„ç†æµç¨‹ï¼Œå®ç°æ ·å¼ç»§æ‰¿é“¾',
  dependencies: ['StyleProcessorPlugin', 'ParagraphProcessorPlugin', 'RunProcessorPlugin']
})
export class TextProcessorPlugin extends BasePlugin implements ITextProcessorPlugin {
  // Metadata will be set by @Plugin decorator
  metadata!: PluginMetadata;

  @InjectPlugin('StyleProcessorPlugin')
  private stylePlugin!: StyleProcessorPlugin;

  @InjectPlugin('ParagraphProcessorPlugin')
  private readonly paragraphPlugin!: ParagraphProcessorPlugin;


  /**
   * å¤„ç†æ–‡æœ¬å…ƒç´ 
   */
  processText(
    element: OpenXMLElement,
    context: ToJsonContext,
    inheritedStyle?: Record<string, any>
  ): TextProcessingResult {
    // å¦‚æœæœ‰å ä½ç¬¦ä¿¡æ¯ï¼Œä» inheritedStyle ä¸­æå–
    const placeholderInfo = inheritedStyle?.placeholderInfo as
      | PlaceholderInfo
      | undefined;

    // 1. æ„å»ºæ ·å¼ç»§æ‰¿é“¾
    const styleChain = this.buildStyleInheritanceChain(
      element,
      context,
      placeholderInfo
    );

    // 2. è·å–æ–‡æœ¬å†…å®¹èŠ‚ç‚¹ (txBody)
    const txBodyNode = this.findNode(element, "txBody");
    if (!txBodyNode) {
      return {
        paragraphs: [],
        hasContent: false,
        style: styleChain,
      };
    }

    // 3. å¤„ç† lstStyle (åˆ—è¡¨æ ·å¼)
    const lstStyleNode = this.findNode(txBodyNode, "lstStyle");
    let finalStyleChain = styleChain;

    if (lstStyleNode) {
      // å­˜åœ¨ lstStyleNode
      const hasValidListStyle = lstStyleNode.children && lstStyleNode.children.length > 0;

      if (hasValidListStyle) {
        // lstStyleNode æœ‰å†…å®¹ï¼Œä½¿ç”¨å½“å‰å…ƒç´ çš„ lstStyle
        const listStyles = this.stylePlugin.extractListStyles(
          lstStyleNode,
          context
        );
        finalStyleChain = this.stylePlugin.mergeStyles(styleChain, listStyles);
      } else if (placeholderInfo) {
        // lstStyleNode å­˜åœ¨ä½†ä¸ºç©ºï¼Œéœ€è¦ä»ç»§æ‰¿é“¾è·å–åˆ—è¡¨æ ·å¼
        // ç»§æ‰¿é¡ºåºï¼šmaster -> layoutï¼ˆlayout ä¼˜å…ˆçº§æ›´é«˜ï¼Œå¯ä»¥è¦†ç›– masterï¼‰

        // 3.1 é¦–å…ˆä»æ¯ç‰ˆçš„ textStyles è·å–åŸºç¡€åˆ—è¡¨æ ·å¼
        const masterListStyles = this.stylePlugin.extractMasterListStyles(
          context,
          placeholderInfo.type
        );

        // 3.2 æ£€æŸ¥å¸ƒå±€å ä½ç¬¦çš„ lstStyleï¼ˆå¯èƒ½åŒ…å« buNone æ¥è¦†ç›–æ¯ç‰ˆçš„åˆ—è¡¨æ ·å¼ï¼‰
        let layoutListStyles: Record<string, any> = {};
        if (placeholderInfo.layoutNode) {
          const layoutTxBody = this.findNode(placeholderInfo.layoutNode, 'txBody');
          if (layoutTxBody) {
            const layoutLstStyle = this.findNode(layoutTxBody, 'lstStyle');
            if (layoutLstStyle && layoutLstStyle.children && layoutLstStyle.children.length > 0) {
              layoutListStyles = this.stylePlugin.extractListStyles(layoutLstStyle, context);
              console.log(
                `[TextProcessorPlugin] Found layout lstStyle for placeholder type: ${placeholderInfo.type}`,
                layoutListStyles
              );
            }
          }
        }

        // 3.3 åˆå¹¶æ ·å¼ï¼šå…ˆåº”ç”¨æ¯ç‰ˆæ ·å¼ï¼Œå†ç”¨å¸ƒå±€æ ·å¼è¦†ç›–
        if (Object.keys(masterListStyles).length > 0 || Object.keys(layoutListStyles).length > 0) {
          console.log(
            `[TextProcessorPlugin] lstStyle is empty, inheriting from master for placeholder type: ${placeholderInfo.type}`,
            { masterListStyles, layoutListStyles }
          );
          // å¸ƒå±€æ ·å¼ä¼˜å…ˆçº§æ›´é«˜ï¼Œæ”¾åœ¨åé¢è¦†ç›–æ¯ç‰ˆæ ·å¼
          finalStyleChain = this.stylePlugin.mergeStyles(
            styleChain,
            masterListStyles,
            layoutListStyles
          );
        }
      }
    }

    // 4. å°†å ä½ç¬¦ä¿¡æ¯åŒ…å«åœ¨ç»§æ‰¿æ ·å¼ä¸­
    const inheritedData = {
      ...finalStyleChain,
      placeholderInfo: placeholderInfo,
    };

    // 5. å¤„ç†æ‰€æœ‰æ®µè½
    const paragraphDatas = this.paragraphPlugin.processParagraphs(
      txBodyNode,
      context,
      inheritedData
    );

    // è½¬æ¢ä¸º ParagraphInfo[]
    const paragraphs: ParagraphInfo[] = paragraphDatas.map((p) => ({
      runs: p.runs || [],
      style: p.style || {},
      level: p.level || 0,
      listType: p.listType,
      listChar: p.listChar,
      numberType: p.numberType,
    }));

    // 4. åˆ¤æ–­æ˜¯å¦æœ‰å†…å®¹
    const hasContent =
      paragraphs.length > 0 &&
      !(paragraphs.length === 1 && paragraphs[0].runs.length === 0) &&
      paragraphs.some((p) => p.runs.some((r) => r.text.trim() !== ""));

    // ä» styleChain ä¸­åˆ†ç¦»å‡ºä¸åº”åœ¨é¡¶çº§ style çš„å±æ€§
    const {
      listType,
      listChar,
      bulletFont,
      bulletSizePercent,
      bulletSizePoints,
      bulletColor,
      numberType,
      startAt,
      levelStyles,
      level,
      ...cleanStyle
    } = styleChain || {};

    return {
      paragraphs,
      hasContent,
      style: cleanStyle,
      placeholderType: placeholderInfo?.type,
      placeholderIndex: placeholderInfo?.idx,
    };
  }

  /**
   * å®Œæ•´çš„æ–‡æœ¬å¤„ç†æµç¨‹
   */
  processFullText(
    xmlElement: OpenXMLElement,
    context: ToJsonContext,
    placeholderInfo?: PlaceholderInfo
  ): TextProcessingResult {
    // æ„å»ºå¸¦å ä½ç¬¦ä¿¡æ¯çš„ç»§æ‰¿æ ·å¼
    const inheritedStyle = placeholderInfo ? { placeholderInfo } : undefined;
    return this.processText(xmlElement, context, inheritedStyle);
  }

  /**
   * å¤„ç†å ä½ç¬¦æ–‡æœ¬
   */
  processPlaceholderText(
    placeholderInfo: PlaceholderInfo,
    context: ToJsonContext
  ): TextProcessingResult {
    // è·å–å ä½ç¬¦çš„é»˜è®¤æ–‡æœ¬
    const placeholderText = this.getPlaceholderDefaultText(placeholderInfo.type);

    // æ„å»ºå ä½ç¬¦çš„æ ·å¼
    const themeStyles = this.stylePlugin.extractThemeStyles(context);
    const masterStyles = this.stylePlugin.extractMasterStyles(context, placeholderInfo.type);
    const placeholderStyle = { color: '#999999', fontStyle: 'italic' }; // å ä½ç¬¦æ–‡æœ¬çš„é»˜è®¤æ ·å¼

    const style = this.stylePlugin.mergeStyles(
      themeStyles,
      masterStyles,
      placeholderStyle
    );

    const paragraphData: ParagraphInfo = {
      runs: [{
        text: placeholderText,
        style: style || {}
      }],
      style: style || {},
      level: 0
    };

    return {
      paragraphs: [paragraphData],
      hasContent: true, // å ä½ç¬¦æ–‡æœ¬ç®—ä½œæœ‰å†…å®¹
      style,
      placeholderType: placeholderInfo.type,
      placeholderIndex: placeholderInfo.idx
    };
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰å®é™…å†…å®¹
   */
  hasActualContent(txBodyNode?: OpenXMLElement): boolean {
    if (!txBodyNode) return false;

    const pElements = this.findNodes(txBodyNode, 'p');
    for (const pElement of pElements) {
      const rElements = this.findNodes(pElement, 'r');
      for (const rElement of rElements) {
        const tElement = this.findNode(rElement, 't');
        if (tElement?.textContent?.trim()) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * æ„å»ºæ ·å¼ç»§æ‰¿é“¾
   */
  buildStyleInheritanceChain(
    xmlElement: OpenXMLElement,
    context: ToJsonContext,
    placeholderInfo?: PlaceholderInfo
  ): Record<string, unknown> {
    const styles: Array<Record<string, unknown>> = [];

    // 1. ä¸»é¢˜é»˜è®¤æ ·å¼ï¼ˆæœ€ä½ä¼˜å…ˆçº§ï¼‰
    const themeStyles = this.stylePlugin.extractThemeStyles(context);
    if (Object.keys(themeStyles).length > 0) {
      styles.push(themeStyles);
    }

    // 2. æ¯ç‰ˆæ ·å¼ï¼ˆåŸºäºå ä½ç¬¦ç±»å‹ï¼‰
    if (placeholderInfo?.type) {
      const masterStyles = this.stylePlugin.extractMasterStyles(context, placeholderInfo.type);
      console.log(
        "ğŸ” Debug - Extracted master styles for type:",
        placeholderInfo.type,
        masterStyles
      );
      if (Object.keys(masterStyles).length > 0) {
        styles.push(masterStyles);
      }
    }

    // 3. ä»å ä½ç¬¦ç»§æ‰¿é“¾è·å–æ ·å¼
    if (placeholderInfo) {
      // 3a. æ¯ç‰ˆå ä½ç¬¦æ ·å¼
      if (placeholderInfo.masterElement?.style) {
        styles.push(placeholderInfo.masterElement.style);
      }

      // 3b. å¸ƒå±€å ä½ç¬¦æ ·å¼
      if (placeholderInfo.layoutElement?.style) {
        styles.push(placeholderInfo.layoutElement.style);
      }
    }

    // 4. å½“å‰å…ƒç´ çš„å½¢çŠ¶å±æ€§æ ·å¼ (spPr)
    const spPrNode = this.findNode(xmlElement, 'spPr');
    if (spPrNode) {
      const shapeStyles = this.extractShapeStyles(spPrNode, context);
      if (Object.keys(shapeStyles).length > 0) {
        styles.push(shapeStyles);
      }
    }

    // 5. æ–‡æœ¬æ¡†å±æ€§æ ·å¼ (bodyPr)
    const txBodyNode = this.findNode(xmlElement, 'txBody');
    if (txBodyNode) {
      const bodyPrNode = this.findNode(txBodyNode, 'bodyPr');
      if (bodyPrNode) {
        const bodyStyles = this.stylePlugin.extractTextBodyProperties(bodyPrNode);
        if (Object.keys(bodyStyles).length > 0) {
          styles.push(bodyStyles);
        }
      }
    }

    // åˆå¹¶æ‰€æœ‰æ ·å¼å±‚
    return this.stylePlugin.mergeStyles(...styles);
  }

  /**
   * ä»å½¢çŠ¶å±æ€§ä¸­æå–æ ·å¼
   */
  private extractShapeStyles(spPrNode: OpenXMLElement, context: ToJsonContext): Record<string, unknown> {
    const styles: Record<string, unknown> = {};

    // èƒŒæ™¯å¡«å……
    const solidFillNode = this.findNode(spPrNode, 'solidFill');
    if (solidFillNode) {
      styles.backgroundColor = this.stylePlugin.extractColor(solidFillNode, context);
    }

    // è¾¹æ¡†
    const lnNode = this.findNode(spPrNode, 'ln');
    if (lnNode) {
      const w = this.getAttribute(lnNode, 'w');
      const lnSolidFillNode = this.findNode(lnNode, 'solidFill');

      if (w) {
        const borderWidth = parseInt(w) / 12700; // EMU to pixels
        styles.borderWidth = `${borderWidth}px`;
      }

      if (lnSolidFillNode) {
        styles.borderColor = this.stylePlugin.extractColor(lnSolidFillNode, context);
      }

      styles.borderStyle = 'solid';
    }

    return styles;
  }

  /**
   * è·å–å ä½ç¬¦çš„é»˜è®¤æ–‡æœ¬
   */
  getPlaceholderDefaultText(type?: string): string {
    const placeholderTexts: Record<string, string> = {
      'title': 'Click to add title',
      'ctrTitle': 'Click to add title',
      'subTitle': 'Click to add subtitle',
      'body': 'Click to add text',
      'tbl': 'Click to add table',
      'chart': 'Click to add chart',
      'clipArt': 'Click to add clip art',
      'dgm': 'Click to add diagram',
      'media': 'Click to add media',
      'pic': 'Click to add picture',
      'dt': new Date().toLocaleDateString(),
      'ftr': 'Footer',
      'hdr': 'Header',
      'sldNum': '1'
    };

    return placeholderTexts[type || ''] || 'Click to add content';
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡æœ¬å ä½ç¬¦
   */
  isTextPlaceholder(placeholderInfo?: PlaceholderInfo): boolean {
    if (!placeholderInfo || !placeholderInfo.type) return false;
    const textTypes = ['title', 'ctrTitle', 'body', 'subTitle', 'dt', 'ftr', 'hdr', 'sldNum'];
    return textTypes.includes(placeholderInfo.type);
  }

  /**
   * æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„å­èŠ‚ç‚¹
   */
  protected findNodes(parent: OpenXMLElement, tagName: string): OpenXMLElement[] {
    const nodes: OpenXMLElement[] = [];

    if (!parent.children) return nodes;

    for (const child of parent.children) {
      const childTagName = child.tagName.split(':').pop() || child.tagName;
      if (childTagName === tagName) {
        nodes.push(child);
      }
    }

    return nodes;
  }
}